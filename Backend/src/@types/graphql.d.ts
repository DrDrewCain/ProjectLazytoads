/** Declaration file generated by dts-gen */

export class GraphQLDirective {
    constructor(...args: any[]);

    toConfig(...args: any[]): void;

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLEnumType {
    constructor(...args: any[]);

    getValue(...args: any[]): void;

    getValues(...args: any[]): void;

    parseLiteral(...args: any[]): void;

    parseValue(...args: any[]): void;

    serialize(...args: any[]): void;

    toConfig(...args: any[]): void;

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLError {
    constructor(...args: any[]);

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

    static captureStackTrace(p0: any, p1: any): any;

    static stackTraceLimit: number;

}

export class GraphQLInputObjectType {
    constructor(...args: any[]);

    getFields(...args: any[]): void;

    toConfig(...args: any[]): void;

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLInterfaceType {
    constructor(...args: any[]);

    getFields(...args: any[]): void;

    getInterfaces(...args: any[]): void;

    toConfig(...args: any[]): void;

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLList {
    constructor(...args: any[]);

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLNonNull {
    constructor(...args: any[]);

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLObjectType {
    constructor(...args: any[]);

    getFields(...args: any[]): void;

    getInterfaces(...args: any[]): void;

    toConfig(...args: any[]): void;

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLScalarType {
    constructor(...args: any[]);

    toConfig(...args: any[]): void;

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class GraphQLSchema {
    constructor(...args: any[]);

    getDirective(...args: any[]): void;

    getDirectives(...args: any[]): void;

    getImplementations(...args: any[]): void;

    getMutationType(...args: any[]): void;

    getPossibleTypes(...args: any[]): void;

    getQueryType(...args: any[]): void;

    getRootType(...args: any[]): void;

    getSubscriptionType(...args: any[]): void;

    getType(...args: any[]): void;

    getTypeMap(...args: any[]): void;

    isSubType(...args: any[]): void;

    toConfig(...args: any[]): void;

}

export class GraphQLUnionType {
    constructor(...args: any[]);

    getTypes(...args: any[]): void;

    toConfig(...args: any[]): void;

    toJSON(...args: any[]): void;

    toString(...args: any[]): void;

}

export class Lexer {
    constructor(...args: any[]);

    advance(...args: any[]): void;

    lookahead(...args: any[]): void;

}

export class Location {
    constructor(...args: any[]);

    toJSON(...args: any[]): void;

}

export class Token {
    constructor(...args: any[]);

    toJSON(...args: any[]): void;

}

export class TypeInfo {
    constructor(...args: any[]);

    enter(...args: any[]): void;

    getArgument(...args: any[]): void;

    getDefaultValue(...args: any[]): void;

    getDirective(...args: any[]): void;

    getEnumValue(...args: any[]): void;

    getFieldDef(...args: any[]): void;

    getInputType(...args: any[]): void;

    getParentInputType(...args: any[]): void;

    getParentType(...args: any[]): void;

    getType(...args: any[]): void;

    leave(...args: any[]): void;

}

export class ValidationContext {
    constructor(...args: any[]);

    getArgument(...args: any[]): void;

    getDirective(...args: any[]): void;

    getEnumValue(...args: any[]): void;

    getFieldDef(...args: any[]): void;

    getInputType(...args: any[]): void;

    getParentInputType(...args: any[]): void;

    getParentType(...args: any[]): void;

    getRecursiveVariableUsages(...args: any[]): void;

    getSchema(...args: any[]): void;

    getType(...args: any[]): void;

    getVariableUsages(...args: any[]): void;

}

export const BREAK: {
};

export const BreakingChangeType: {
    ARG_CHANGED_KIND: string;
    ARG_REMOVED: string;
    DIRECTIVE_ARG_REMOVED: string;
    DIRECTIVE_LOCATION_REMOVED: string;
    DIRECTIVE_REMOVED: string;
    DIRECTIVE_REPEATABLE_REMOVED: string;
    FIELD_CHANGED_KIND: string;
    FIELD_REMOVED: string;
    IMPLEMENTED_INTERFACE_REMOVED: string;
    REQUIRED_ARG_ADDED: string;
    REQUIRED_DIRECTIVE_ARG_ADDED: string;
    REQUIRED_INPUT_FIELD_ADDED: string;
    TYPE_CHANGED_KIND: string;
    TYPE_REMOVED: string;
    TYPE_REMOVED_FROM_UNION: string;
    VALUE_REMOVED_FROM_ENUM: string;
};

export const DEFAULT_DEPRECATION_REASON: string;

export const DangerousChangeType: {
    ARG_DEFAULT_VALUE_CHANGE: string;
    IMPLEMENTED_INTERFACE_ADDED: string;
    OPTIONAL_ARG_ADDED: string;
    OPTIONAL_INPUT_FIELD_ADDED: string;
    TYPE_ADDED_TO_UNION: string;
    VALUE_ADDED_TO_ENUM: string;
};

export const DirectiveLocation: {
    ARGUMENT_DEFINITION: string;
    ENUM: string;
    ENUM_VALUE: string;
    FIELD: string;
    FIELD_DEFINITION: string;
    FRAGMENT_DEFINITION: string;
    FRAGMENT_SPREAD: string;
    INLINE_FRAGMENT: string;
    INPUT_FIELD_DEFINITION: string;
    INPUT_OBJECT: string;
    INTERFACE: string;
    MUTATION: string;
    OBJECT: string;
    QUERY: string;
    SCALAR: string;
    SCHEMA: string;
    SUBSCRIPTION: string;
    UNION: string;
    VARIABLE_DEFINITION: string;
};

export const GRAPHQL_MAX_INT: number;

export const GRAPHQL_MIN_INT: number;

export const Kind: {
    ARGUMENT: string;
    BOOLEAN: string;
    DIRECTIVE: string;
    DIRECTIVE_DEFINITION: string;
    DOCUMENT: string;
    ENUM: string;
    ENUM_TYPE_DEFINITION: string;
    ENUM_TYPE_EXTENSION: string;
    ENUM_VALUE_DEFINITION: string;
    FIELD: string;
    FIELD_DEFINITION: string;
    FLOAT: string;
    FRAGMENT_DEFINITION: string;
    FRAGMENT_SPREAD: string;
    INLINE_FRAGMENT: string;
    INPUT_OBJECT_TYPE_DEFINITION: string;
    INPUT_OBJECT_TYPE_EXTENSION: string;
    INPUT_VALUE_DEFINITION: string;
    INT: string;
    INTERFACE_TYPE_DEFINITION: string;
    INTERFACE_TYPE_EXTENSION: string;
    LIST: string;
    LIST_TYPE: string;
    NAME: string;
    NAMED_TYPE: string;
    NON_NULL_TYPE: string;
    NULL: string;
    OBJECT: string;
    OBJECT_FIELD: string;
    OBJECT_TYPE_DEFINITION: string;
    OBJECT_TYPE_EXTENSION: string;
    OPERATION_DEFINITION: string;
    OPERATION_TYPE_DEFINITION: string;
    SCALAR_TYPE_DEFINITION: string;
    SCALAR_TYPE_EXTENSION: string;
    SCHEMA_DEFINITION: string;
    SCHEMA_EXTENSION: string;
    SELECTION_SET: string;
    STRING: string;
    UNION_TYPE_DEFINITION: string;
    UNION_TYPE_EXTENSION: string;
    VARIABLE: string;
    VARIABLE_DEFINITION: string;
};

export const OperationTypeNode: {
    MUTATION: string;
    QUERY: string;
    SUBSCRIPTION: string;
};

export const TokenKind: {
    AMP: string;
    AT: string;
    BANG: string;
    BLOCK_STRING: string;
    BRACE_L: string;
    BRACE_R: string;
    BRACKET_L: string;
    BRACKET_R: string;
    COLON: string;
    COMMENT: string;
    DOLLAR: string;
    EOF: string;
    EQUALS: string;
    FLOAT: string;
    INT: string;
    NAME: string;
    PAREN_L: string;
    PAREN_R: string;
    PIPE: string;
    SOF: string;
    SPREAD: string;
    STRING: string;
};

export const TypeKind: {
    ENUM: string;
    INPUT_OBJECT: string;
    INTERFACE: string;
    LIST: string;
    NON_NULL: string;
    OBJECT: string;
    SCALAR: string;
    UNION: string;
};

export const introspectionTypes: {
    astNode: any;
    description: string;
    extensionASTNodes: any[];
    extensions: {
    };
    getFields: any;
    getInterfaces: any;
    isTypeOf: any;
    name: string;
    toConfig: any;
    toJSON: any;
    toString: any;
}[];

export const specifiedDirectives: {
    args: {
        astNode: any;
        defaultValue: any;
        deprecationReason: any;
        description: string;
        extensions: {
        };
        name: string;
        type: {
            ofType: {
                astNode: any;
                description: string;
                extensionASTNodes: any[];
                extensions: {
                };
                name: string;
                parseLiteral: any;
                parseValue: any;
                serialize: any;
                specifiedByURL: any;
                toConfig: any;
                toJSON: any;
                toString: any;
            };
            toJSON: any;
            toString: any;
        };
    }[];
    astNode: any;
    description: string;
    extensions: {
    };
    isRepeatable: boolean;
    locations: string[];
    name: string;
    toConfig: any;
    toJSON: any;
    toString: any;
}[];

export const specifiedRules: any[];

export const specifiedScalarTypes: {
    astNode: any;
    description: string;
    extensionASTNodes: any[];
    extensions: {
    };
    name: string;
    parseLiteral: any;
    parseValue: any;
    serialize: any;
    specifiedByURL: any;
    toConfig: any;
    toJSON: any;
    toString: any;
}[];

export const version: string;

export const versionInfo: {
    major: number;
    minor: number;
    patch: number;
    preReleaseTag: any;
};

export function ExecutableDefinitionsRule(context: any): any;

export function FieldsOnCorrectTypeRule(context: any): any;

export function FragmentsOnCompositeTypesRule(context: any): any;

export function KnownArgumentNamesRule(context: any): any;

export function KnownDirectivesRule(context: any): any;

export function KnownFragmentNamesRule(context: any): any;

export function KnownTypeNamesRule(context: any): any;

export function LoneAnonymousOperationRule(context: any): any;

export function LoneSchemaDefinitionRule(context: any): any;

export function NoDeprecatedCustomRule(context: any): any;

export function NoFragmentCyclesRule(context: any): any;

export function NoSchemaIntrospectionCustomRule(context: any): any;

export function NoUndefinedVariablesRule(context: any): any;

export function NoUnusedFragmentsRule(context: any): any;

export function NoUnusedVariablesRule(context: any): any;

export function OverlappingFieldsCanBeMergedRule(context: any): any;

export function PossibleFragmentSpreadsRule(context: any): any;

export function PossibleTypeExtensionsRule(context: any): any;

export function ProvidedRequiredArgumentsRule(context: any, ...args: any[]): any;

export function ScalarLeafsRule(context: any): any;

export function SingleFieldSubscriptionsRule(context: any): any;

export function Source(...args: any[]): any;

export function UniqueArgumentDefinitionNamesRule(context: any, ...args: any[]): any;

export function UniqueArgumentNamesRule(context: any, ...args: any[]): any;

export function UniqueDirectiveNamesRule(context: any): any;

export function UniqueDirectivesPerLocationRule(context: any): any;

export function UniqueEnumValueNamesRule(context: any): any;

export function UniqueFieldDefinitionNamesRule(context: any): any;

export function UniqueFragmentNamesRule(context: any): any;

export function UniqueInputFieldNamesRule(context: any): any;

export function UniqueOperationNamesRule(context: any): any;

export function UniqueOperationTypesRule(context: any): any;

export function UniqueTypeNamesRule(context: any): any;

export function UniqueVariableNamesRule(context: any): any;

export function ValuesOfCorrectTypeRule(context: any): any;

export function VariablesAreInputTypesRule(context: any): any;

export function VariablesInAllowedPositionRule(context: any): any;

export function assertAbstractType(type: any): any;

export function assertCompositeType(type: any): any;

export function assertDirective(directive: any): any;

export function assertEnumType(type: any): any;

export function assertEnumValueName(name: any): any;

export function assertInputObjectType(type: any): any;

export function assertInputType(type: any): any;

export function assertInterfaceType(type: any): any;

export function assertLeafType(type: any): any;

export function assertListType(type: any): any;

export function assertName(name: any): any;

export function assertNamedType(type: any): any;

export function assertNonNullType(type: any): any;

export function assertNullableType(type: any): any;

export function assertObjectType(type: any): any;

export function assertOutputType(type: any): any;

export function assertScalarType(type: any): any;

export function assertSchema(schema: any): any;

export function assertType(type: any): any;

export function assertUnionType(type: any): any;

export function assertValidName(name: any): any;

export function assertValidSchema(schema: any): void;

export function assertWrappingType(type: any): any;

export function astFromValue(value: any, type: any): any;

export function buildASTSchema(documentAST: any, options: any): any;

export function buildClientSchema(introspection: any, options: any): any;

export function buildSchema(source: any, options: any): any;

export function coerceInputValue(inputValue: any, type: any, onError: any): any;

export function concatAST(documents: any): any;

export function createSourceEventStream(rawArgs: any): any;

export function defaultFieldResolver(source: any, args: any, contextValue: any, info: any): any;

export function defaultTypeResolver(value: any, contextValue: any, info: any, abstractType: any): any;

export function doTypesOverlap(schema: any, typeA: any, typeB: any): any;

// export function execute(args: any, ...args: any[]): any;

export function executeSync(args: any): any;

export function extendSchema(schema: any, documentAST: any, options: any): any;

export function findBreakingChanges(oldSchema: any, newSchema: any): any;

export function findDangerousChanges(oldSchema: any, newSchema: any): any;

export function formatError(error: any): any;

export function getArgumentValues(def: any, node: any, variableValues: any, ...args: any[]): any;

export function getDirectiveValues(directiveDef: any, node: any, variableValues: any): any;

export function getEnterLeaveForKind(visitor: any, kind: any): any;

export function getIntrospectionQuery(options: any): any;

export function getLocation(source: any, position: any): any;

export function getNamedType(type: any): any;

export function getNullableType(type: any): any;

export function getOperationAST(documentAST: any, operationName: any): any;

export function getOperationRootType(schema: any, operation: any): any;

export function getVariableValues(schema: any, varDefNodes: any, inputs: any, options: any): any;

export function getVisitFn(visitor: any, kind: any, isLeaving: any): any;

export function graphql(args: any): any;

export function graphqlSync(args: any): any;

export function introspectionFromSchema(schema: any, options: any): any;

export function isAbstractType(type: any): any;

export function isCompositeType(type: any): any;

export function isConstValueNode(node: any): any;

export function isDefinitionNode(node: any): any;

export function isDirective(directive: any): any;

export function isEnumType(type: any): any;

export function isEqualType(typeA: any, typeB: any): any;

export function isExecutableDefinitionNode(node: any): any;

export function isInputObjectType(type: any): any;

export function isInputType(type: any): any;

export function isInterfaceType(type: any): any;

export function isIntrospectionType(type: any): any;

export function isLeafType(type: any): any;

export function isListType(type: any): any;

export function isNamedType(type: any): any;

export function isNonNullType(type: any): any;

export function isNullableType(type: any): any;

export function isObjectType(type: any): any;

export function isOutputType(type: any): any;

export function isRequiredArgument(arg: any): any;

export function isRequiredInputField(field: any): any;

export function isScalarType(type: any): any;

export function isSchema(schema: any): any;

export function isSelectionNode(node: any): any;

export function isSpecifiedDirective(directive: any): any;

export function isSpecifiedScalarType(type: any): any;

export function isType(type: any): any;

export function isTypeDefinitionNode(node: any): any;

export function isTypeExtensionNode(node: any): any;

export function isTypeNode(node: any): any;

export function isTypeSubTypeOf(schema: any, maybeSubType: any, superType: any): any;

export function isTypeSystemDefinitionNode(node: any): any;

export function isTypeSystemExtensionNode(node: any): any;

export function isUnionType(type: any): any;

export function isValidNameError(name: any): any;

export function isValueNode(node: any): any;

export function isWrappingType(type: any): any;

export function lexicographicSortSchema(schema: any): any;

export function locatedError(rawOriginalError: any, nodes: any, path: any): any;

export function parse(source: any, options: any): any;

export function parseConstValue(source: any, options: any): any;

export function parseType(source: any, options: any): any;

export function parseValue(source: any, options: any): any;

export function print(ast: any): any;

export function printError(error: any): any;

export function printIntrospectionSchema(schema: any): any;

export function printLocation(location: any): any;

export function printSchema(schema: any): any;

export function printSourceLocation(source: any, sourceLocation: any): any;

export function printType(type: any): any;

export function resolveObjMapThunk(thunk: any): any;

export function resolveReadonlyArrayThunk(thunk: any): any;

export function responsePathAsArray(path: any): any;

export function separateOperations(documentAST: any): any;

export function stripIgnoredCharacters(source: any): any;

// export function subscribe(args: any, ...args: any[]): any;

export function syntaxError(source: any, position: any, description: any): any;

export function typeFromAST(schema: any, typeNode: any): any;

export function validate(schema: any, documentAST: any, rules: any, options: any, typeInfo: any): any;

export function validateSchema(schema: any): any;

export function valueFromAST(valueNode: any, type: any, variables: any): any;

export function valueFromASTUntyped(valueNode: any, variables: any): any;

export function visit(root: any, visitor: any, visitorKeys: any): any;

export function visitInParallel(visitors: any): any;

export function visitWithTypeInfo(typeInfo: any, visitor: any): any;

export namespace GraphQLBoolean {
    const astNode: any;

    const description: string;

    const extensionASTNodes: any[];

    const extensions: {
    };

    const name: string;

    const specifiedByURL: any;

    function parseLiteral(...args: any[]): void;

    function parseValue(...args: any[]): void;

    function serialize(...args: any[]): void;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLDeprecatedDirective {
    const args: {
        astNode: any;
        defaultValue: string;
        deprecationReason: any;
        description: string;
        extensions: {
        };
        name: string;
        type: {
            astNode: any;
            description: string;
            extensionASTNodes: any[];
            extensions: {
            };
            name: string;
            parseLiteral: any;
            parseValue: any;
            serialize: any;
            specifiedByURL: any;
            toConfig: any;
            toJSON: any;
            toString: any;
        };
    }[];

    const astNode: any;

    const description: string;

    const extensions: {
    };

    const isRepeatable: boolean;

    const locations: string[];

    const name: string;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLFloat {
    const astNode: any;

    const description: string;

    const extensionASTNodes: any[];

    const extensions: {
    };

    const name: string;

    const specifiedByURL: any;

    function parseLiteral(...args: any[]): void;

    function parseValue(...args: any[]): void;

    function serialize(...args: any[]): void;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLID {
    const astNode: any;

    const description: string;

    const extensionASTNodes: any[];

    const extensions: {
    };

    const name: string;

    const specifiedByURL: any;

    function parseLiteral(...args: any[]): void;

    function parseValue(...args: any[]): void;

    function serialize(...args: any[]): void;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLIncludeDirective {
    const args: {
        astNode: any;
        defaultValue: any;
        deprecationReason: any;
        description: string;
        extensions: {
        };
        name: string;
        type: {
            ofType: {
                astNode: any;
                description: string;
                extensionASTNodes: any[];
                extensions: {
                };
                name: string;
                parseLiteral: any;
                parseValue: any;
                serialize: any;
                specifiedByURL: any;
                toConfig: any;
                toJSON: any;
                toString: any;
            };
            toJSON: any;
            toString: any;
        };
    }[];

    const astNode: any;

    const description: string;

    const extensions: {
    };

    const isRepeatable: boolean;

    const locations: string[];

    const name: string;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLInt {
    const astNode: any;

    const description: string;

    const extensionASTNodes: any[];

    const extensions: {
    };

    const name: string;

    const specifiedByURL: any;

    function parseLiteral(...args: any[]): void;

    function parseValue(...args: any[]): void;

    function serialize(...args: any[]): void;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLSkipDirective {
    const args: {
        astNode: any;
        defaultValue: any;
        deprecationReason: any;
        description: string;
        extensions: {
        };
        name: string;
        type: {
            ofType: {
                astNode: any;
                description: string;
                extensionASTNodes: any[];
                extensions: {
                };
                name: string;
                parseLiteral: any;
                parseValue: any;
                serialize: any;
                specifiedByURL: any;
                toConfig: any;
                toJSON: any;
                toString: any;
            };
            toJSON: any;
            toString: any;
        };
    }[];

    const astNode: any;

    const description: string;

    const extensions: {
    };

    const isRepeatable: boolean;

    const locations: string[];

    const name: string;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLSpecifiedByDirective {
    const args: {
        astNode: any;
        defaultValue: any;
        deprecationReason: any;
        description: string;
        extensions: {
        };
        name: string;
        type: {
            ofType: {
                astNode: any;
                description: string;
                extensionASTNodes: any[];
                extensions: {
                };
                name: string;
                parseLiteral: any;
                parseValue: any;
                serialize: any;
                specifiedByURL: any;
                toConfig: any;
                toJSON: any;
                toString: any;
            };
            toJSON: any;
            toString: any;
        };
    }[];

    const astNode: any;

    const description: string;

    const extensions: {
    };

    const isRepeatable: boolean;

    const locations: string[];

    const name: string;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace GraphQLString {
    const astNode: any;

    const description: string;

    const extensionASTNodes: any[];

    const extensions: {
    };

    const name: string;

    const specifiedByURL: any;

    function parseLiteral(...args: any[]): void;

    function parseValue(...args: any[]): void;

    function serialize(...args: any[]): void;

    function toConfig(...args: any[]): void;

    function toJSON(...args: any[]): void;

    function toString(...args: any[]): void;

}

export namespace SchemaMetaFieldDef {
    const args: any[];

    const astNode: any;

    const deprecationReason: any;

    const description: string;

    const extensions: {
    };

    const name: string;

    function resolve(_source: any, _args: any, _context: any, { schema }: any): void;

    namespace type {
        function toJSON(...args: any[]): void;

        function toString(...args: any[]): void;

        namespace ofType {
            const astNode: any;

            const description: string;

            const extensionASTNodes: any[];

            const extensions: {
            };

            const isTypeOf: any;

            const name: string;

            function getFields(...args: any[]): void;

            function getInterfaces(...args: any[]): void;

            function toConfig(...args: any[]): void;

            function toJSON(...args: any[]): void;

            function toString(...args: any[]): void;

        }

    }

}

export namespace TypeMetaFieldDef {
    const args: {
        astNode: any;
        defaultValue: any;
        deprecationReason: any;
        description: any;
        extensions: {
        };
        name: string;
        type: {
            ofType: {
                astNode: any;
                description: string;
                extensionASTNodes: any[];
                extensions: {
                };
                name: string;
                parseLiteral: any;
                parseValue: any;
                serialize: any;
                specifiedByURL: any;
                toConfig: any;
                toJSON: any;
                toString: any;
            };
            toJSON: any;
            toString: any;
        };
    }[];

    const astNode: any;

    const deprecationReason: any;

    const description: string;

    const extensions: {
    };

    const name: string;

    function resolve(_source: any, { name }: any, _context: any, { schema }: any): void;

    namespace type {
        const astNode: any;

        const description: string;

        const extensionASTNodes: any[];

        const extensions: {
        };

        const isTypeOf: any;

        const name: string;

        function getFields(...args: any[]): void;

        function getInterfaces(...args: any[]): void;

        function toConfig(...args: any[]): void;

        function toJSON(...args: any[]): void;

        function toString(...args: any[]): void;

    }

}

export namespace TypeNameMetaFieldDef {
    const args: any[];

    const astNode: any;

    const deprecationReason: any;

    const description: string;

    const extensions: {
    };

    const name: string;

    function resolve(_source: any, _args: any, _context: any, { parentType }: any): void;

    namespace type {
        function toJSON(...args: any[]): void;

        function toString(...args: any[]): void;

        namespace ofType {
            const astNode: any;

            const description: string;

            const extensionASTNodes: any[];

            const extensions: {
            };

            const name: string;

            const specifiedByURL: any;

            function parseLiteral(...args: any[]): void;

            function parseValue(...args: any[]): void;

            function serialize(...args: any[]): void;

            function toConfig(...args: any[]): void;

            function toJSON(...args: any[]): void;

            function toString(...args: any[]): void;

        }

    }

}

